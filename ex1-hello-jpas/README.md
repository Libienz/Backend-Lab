

<details>
<summary>01. 영속성 컨텍스트 </summary>
<div markdown="1">

### 영속성 컨텍스트
- 엔티티를 영구 저장하는 환경

### 엔티티의 생명주기
- 비영속
  - (new/transient) 영속성 컨텍스트와 전혀 관계가 없는 새로운 상태
- 영속
  - 영속성 컨텍스트에 관리되는 상태
- 준영속
  - 영속성 컨텍스트에 저장되었다가 분리된 상태
- 삭제
  - 삭제된 상태 
  - em.remove(member) 객체 자체를 삭제

![img.png](imgs/img.png)

### 영속성 컨텍스트를 사용하여 얻는 이점
- 강의에서도 얘기했지만 항상 어떤 것과 어떤 것을 매핑하는 중간계층의 컨텍스트를 사용할 경우 크게 두 가지의 이점을 얻을 수 있다
1. buffered 작업
2. 캐시 이용
- 영속성 컨텍스트 역시 RDB와 객체 엔티티간의 매핑으로써 다음의 이점을 얻을 수 있다
  - 1차 캐시 
    - em.persist로 객체를 영속화 할 경우 em.find할 때 1차 캐시에서 조회할 수 있다.
    - DB connection과 반복되는 쿼리 작업을 을 줄일 수 있다.
    - 만약 em.find를 한경우 cache miss가 나면 DB에서 꺼내와서 1차 캐시에 객체를 담아 둔다.
  - 동일성 보장
    - Member a = em.find(Member.class, 1L);
    - Member b = em.find(Member.class, 1L);
    - a == b가 성립한다. 
    - 어려운 말로 1차 캐시로 반복 가능한 읽기 등급의 트랜잭션 격리 수준을 데이터베이스가 아닌 애플리케이션 차원에서 제공한다고 표현할 수 있다
  - 쓰기 지연
    - 트랜잭션을 지원하는 쓰기 지연
    - em.persist는 객체를 영속화 할 뿐 sql을 실행시키지 않는다.
    - 커밋하는 순간 데이터가 영구화 된다.
    - flush: 데이터베이스에 sql 저장소에 있는 쿼리들을 실행시켜 영속성 컨텍스트와 DB의 내용을 동기화
      - 다만 flush 후 커밋하지 않으면 트랜잭션 단위 roll back이 가능한 상태이다.
    ![img.png](imgs/img_38.png)
  - 변경 감지
    - 이전 실전편에서 데이터를 수정할 경우 memberA.setUsername("h");와 같이 수정하고 따로 persist 할 필요가 없는 것을 보았었다
    - 이와 같은 과정이 가능한 것은 영속성 컨텍스트에 엔티티와 스냅샷을 비교하는 과정이 있기 때문 
    ![img_1.png](imgs/img_1.png)
  - 지연 로딩
- 
</div>
</details>


<details>
<summary>02. 엔티티 매핑 </summary>
<div markdown="1">

### @Entitiy
- @Entity가 붙은 클래스는 jpa가 관리, 엔티티라 한다.
- 테이블과 객체를 매핑할 클래스에 @Entity를 붙여주면 된다.
- 어노테이션을 사용하기 위해서 기본 생성자 필수!(접근 제어는 public 혹은 protected)
- final 클래스, enum, interface, inner 클래스는 사용 불가
- 저장할 필드에 final 사용 X

### 데이터베이스 스키마 자동 생성
- DDL을 애플리케이션 실행 시점에 자동 생성
- propertiy 파일에 DDL 행동의 속성을 설정할 수 있는데 create, create-drop, update, validate, none과 같은 속성들이 있다 
- 운영 장비에는 절대 create, create-drop, update를 사용하지 말자 (전부 지워버리는 수가 있다)
- 개발 초기 단계는 create 또는 update
- 많은 개발자들이 모여서 사용하는 테스트 서버는 update 또는 validate
- 스테이징과 운영 서버는 validate 또는 none을 사용하자

### 필드와 컬럼 매핑
### @Column
  - name: 필드와 매핑할 테이블의 컬럼 이름
  - insertable, updatable: 등록, 변경 가능 여부
  - nullable: 컬럼에 유니크 제약조건을 걸 때 사용
  - columnDefinition: 데이터베이스 컬럼 정보를 직접 줄 수 있다. 
    - ex) varchar(100) default ‘EMPTY'
  - length: 문자 길이 제약 조건
  - precision, scale: bigDecimal 타입에서 사용 floating number의 정밀도와 scale 지정
### @Enumerated
  - 자바 enum 타입을 매핑할 때 사용
  - 두가지 ORDINAL과 STRING 이쓴ㄴ데 항상 STRING을 사용하도록 하자 
### @Temporal
  - 날짜 타입을 매핑할 떄 사용
  - but 충분히 높은 버젼의 hibernate을 사용하고 있다면 LocalDate, LocalDateTime을 @Temporal없이 사용 가능
### @Lob
  - 데이터베이스 BLOB, CLOB 타입과 매핑
  - 지정할 수 있는 속성 없음
  - 매핑하는 필드 타입이 문자면 CLOB 매핑, 나머지는 BLOB 매핑
### @Transient
  - 필드 매핑 X
  - 데이터베이스에 저장 X

### 기본 키 매핑 어노테이션

### @Id
- PK임을 알림
### @GeneratedValue
- 키를 자동 생성 하도록 설정
- Strategies
  - IDENTITY: 데이터베이스에 위임
    - DB에 넣을 때 null로 주고 DB에서 키를 알아서 생성하도록 위임한다
    - 다만 persist 시점에 영속성 컨텍스트에서 관리하기 위해 SQL을 flush시점이 아니더라도 persist 시점에 바로 푸쉬한다.  
    - 버퍼의 장점을 누리지 못하지만 생각보다 cardinal한 성능저하는 일어나지 않음
  - SEQUENCE: 데이터베이스 시퀀스 오브젝트 사용
    - 오라클에서 많이 사용
    - jpa가 시퀀스 값을 db로 부터 가져와서 메모리에 저장한다. 
    - 데이터 베이스에 call next value 쿼리를 보내어 시퀀스 오브젝트의 값을 가져온다
    - 시퀀스 값은 db에서 미리 정의 되어 있는 것이 IDENTITY와의 차이점 (가져온 후에 영속성 컨텍스트에 저장하는 것도 차이점)
    - 시퀀스 제네레이터는 커스텀 가능
      - 특히 주의 깊게 볼 속성은 allocationSize
      - allocationSize = 50(default)으로 하면 DB에서 시퀀스를 가져올 때 50개를 가져와서 로컬 메모리에 저장할 수 있다
      - 1번 할때마다 네트워크를 타면 부담스러우니 allocationSize이용하면 성능 최적화를 이룰 수 있다
      - 이론적으로는 사이즈가 크면 클수록 좋지만 웹서버를 내리는 시점에 id 값의 구멍이 생길 수 있다 (굳이 구멍 생겨도 문제는 없지만)
  - TABLE: 키 생성용 테이블 사용, 모든 DB에서 사용
    - 테이블을 직접사용하다 보니 락도 걸릴 수 있고 성능이 떨어질 수 있음
    - 잘 사용되는 매핑 전략은 아님
  - AUTO: 방언에 따라 자동 지정, default
- 결론은 뭘쓰냐!? 
  - 기본 키는 null이면 안되고 유일해야 하고 변하면 안된다.(서비스의 요소를 pk로 끌어오지 말자)
  - 권장: Long형 + 대체키 + 키 생성전략 사용(AUTO_INCREMENT나 SEQUENCE 전략 사용)
- 

</div>
</details>



<details>
<summary>03. 연관관계 매핑 </summary>
<div markdown="1">

### 데이터 중심 연관관계 모델링
- 회원과 팀이 있고 회원과 팀이 다대일 관계를 맺는 경우를 생각해보자
- 회원 엔티티에 teamId 속성을 두어 객체 간의 연관관계를 맺었다면 이는 객체를 테이블에 맞추어 모델링 한 것
  - 참조 대신에 외래 키를 그대로 사용한 것이다. (실제로 테이블이 이러한 구성)
  - 이는 객체 지향적인 방법은 아니다. 
- 객체를 테이블에 맞추어 데이터 중심으로 모델링 하면, 협력 관계를 만들 수 없다. 
  - 테이블은 외래 키로 조인을 사용해서 연관된 테이블을 찾겠지만 객체는 참조를 이용해서 연관된 객체를 찾아야 하기 때문
  - 테이블과 객체 사이에는 이런 큰 간격이 있다

### 객체 지향 모델링
- 회원과 팀이 있고 회원과 팀이 다대일 관계를 맺는 경우 Member 클래스의 필드에 Team 필드가 존재한다면 Member객체는 참조값을 이용해 연관관계를 맺게 된다.
- 객체 지향적으로 모델링 하면 객체의 참조와 테이블의 외래키를 매핑하게 되는 것이다.
- 결국 jpa가 연관관계 매핑에서 객체와 테이블의 간극을 매핑하는 것

### 단방향 연관관계와 양방향 연관관계
### 단방향
![img_2.png](imgs/img_2.png)
- 멤버는 팀의 참조값을 가지고 있어 연관관계를 맺지만 팀은 Member로 향하는 연관관계를 가지고 있지 않다. 

### 양방향 
![img_3.png](imgs/img_3.png)
- 멤버에서 팀으로의 연관관계뿐만 아니라 역방향 연관관계 역시 가지고 있다 

### 객체와 테이블이 관계를 맺는 차이
- 객체와 테이블간의 연관관계를 맺는 차이를 이해해야 jpa에서 연관관계를 매핑하는 블랙박스를 이해할 수 있다.
- 객체의 양방향 관계는 사실 양방향 관계가 아니라 서로 다른 단방향 관계 2개다 (단방향에서 역방향을 추가해준 것일 뿐)
- 반면 테이블은 외래 키 하나로 두 테이블의 연관관계를 관리하는데 이는 양방향 연관관계이다.(양쪽으로 모두 join 가능)
- 따라서 테이블은 두 테이블 중 하나로 외래키를 관리해야 한다. 
- 외래키를 가지고 있는 쪽은 연관관계의 주인이 되는데 객체의 연관관계를 매핑하려면 이러한 특성에 주목해야 함 

### 연관관계의 주인
- 객체의 두 관계 중 하나를 연관관계의 주인으로 지정해야 한다.
- 연관관계의 주인만이 외래 키를 관리
- 주인이 아닌쪽은 읽기만 가능
- 주인은 mappedBy 속성 사용X
- 주인이 아니면 mappedBy 속성으로 주인 지정
- 객체에서 연관관계의 주인은 외래키가 있는 곳으로 설정해야 함 (de facto standard)

### 양방향 매핑 시 가장 많이 하는 실수
![img_4.png](imgs/img_4.png)
- 연관관계의 주인이 아닌 1쪽 엔티티에만 추가를 해준 후에 member 테이블의 TEAM_ID를 살펴보면 null로 지정되어 있다.
- 연관 관계의 주인은 연관 관계를 갖는 두 객체 사이에서 조회,저장,수정,삭제를 모두 할 수 있지만 연관관계의 주인이 아니면 조회만 가능하다. 
  ### 왜??
    - 멤버에서 팀을 바꾸든지 팀에서 멤버를 바꾸든지 객체 입장에서는 두 방법 다 맞는 방법이긴 하다
    - 하지만 객체에서 이렇게 양방향 연관 관계의 관리 포인트가 두 곳일 때는 테이블과 매핑을 담당하는 JPA에게 혼란을 주게 됨
    - 그렇기 때문에 두 객체 사이의 연관 관계의 주인을 정해서 관리 포인트를 한 곳으로 좁혀 주는 것이 mappedBy인 것! 
  ### 그렇다면 연관관계의 주인만 제어하면 되나?
  - 데이터베이스만 생각했을 때는 맞겠지만 객체를 생각해보면 둘 다 변경해주는 것이 좋다. 두 참조를 사용하는 순수한 두 객체의 데이터 동기화를 위한 것임

### 다음을 권장한다
- 단방향 매핑만으로도 사실 연관관계 매핑은 완료 된 것
- 양방향 매핑은 반대 방향으로 조회(객체 그래프 탐색) 기능이 추가 된 것 뿐
- 단방향 매핑을 잘 수행하는 것이 중요하고 양방향은 필요할 때 추가해도 된다.
- 사실 단방향이 깔끔하다.
  - 문맥상으로도 주문서를 보고 주문에 관한 정보를 찾는 것이 일반적
  - 즉 중간 테이블을 통해 쿼리를 시작하는 것이 일반적이지 멤버에서 getOrders하는 것은 설계 오류라고 볼 수 있을 정도
  - 관심사를 끊어내는 것이 더 깔끔하고 simple하다!


</div>
</details>



<details>
<summary>04. 다양한 연관관계 매핑 </summary>
<div markdown="1">

### 다대일 단방향
- 가장 많이 사용하는 연관관계
![img_5.png](imgs/img_5.png)

### 다대일 양방향
- 외래 키가 있는 쪽이 연관관계의 주인
- 양쪽을 서로 참조하도록 개발
![img_6.png](imgs/img_6.png)

### 일대다 단방향
- 일이 연관관계의 주인
- 테이블은 항상 다 쪽에 외래 키가 있음
- 객체와 테이블의 차이 때문에 반대편 테이블의 외래 키를 관리하는 특이한 구조
- @JoinColumn을 꼭 사용해야 함. 그렇지 않으면 조인 테이블 방식을 사용함(중간에 테이블을 하나 추가)
![img_7.png](imgs/img_7.png)
- 일대다 단방향 매핑의 단점
  - 엔티티가 관리하는 외래 키가 매핑된 테이블이 아닌 다른 테이블에 있음
  - 연관관계 관리를 위해 추가로 UPDATE SQL이 실행된다.
- 일대다 단방향 매핑보다는 다대일 양방향 매핑을 사용하자! 

### 일대다 양방향
![img_8.png](imgs/img_8.png)
- 이런 매핑은 공식적으로 존재하지 않음 -> 야매로 해결한 것
- @JoinColumn(insertable = false, updatable = false)
- 읽기 전용 필드를 사용해서 양방향 처럼 사용하는 방법
- 역시나.. 다대일 양방향을 사용하자

### 일대일: 주 테이블에 외래 키 단방향
- 일대일 관계는 그 반대도 일대일
- 주 테이블이나 대상 테이블 중에 외래 키 선택 가능(주 테이블은 주로 접근하는 테이블쯤으로 이해하자)
- 외래 키에 데이터베이스 유니크 제약조건 추가()
![img_9.png](imgs/img_9.png)

### 일대일: 주 테이블에 외래 키 양방향
- 다대일 양방향 매핑처럼 외래 키가 있는 곳이 연관관계의 주인
- 반대편은 mappedBy 적용
![img_10.png](imgs/img_10.png)

### 일대일: 대상 테이블에 외래 키 단방향
- 단방향 관계는 JPA 지원 X
- 양방향 관계는 지원 

### 일대일: 대상 테이블에 외래키 양방향
![img_11.png](imgs/img_11.png)

### 일대일 정리
- 주 테이블에 외래키
  - 주 객체가 대상 객체의 참조를 가지는 것 처럼 주 테이블에 외래키를 두고 대상 테이블을 찾음
  - 객체지향 개발자 선호
  - JPA 매핑 편리
  - 장점: 주 테이블만 조회해도 대상 테이블에 데이터가 있는지 확인 가능
  - 단점: 값이 없으면 외래 키에 null을 허용하게 된다.
- 대상 테이블에 외래 키 
  - 대상 테이블에 외래 키가 존재
  - 전통적인 데이터베이스 개발자 선호
  - 장점: 주 테이블과 대상 테이블을 일대일에서 일대다 관계로 변경할 때 테이블 구조 유지
  - 단점: 프록시 기능의 한계로 지연 로딩으로 설정해도 항상 즉시 로딩됨
    - 코드 상에서 멤버 엔티티에서 락커를 액세스 할 경우 멤버 객체를 로딩할 때 멤버 테이블의 FK에 락커가 있는지 없는지만 판단하면 된다.
    - 있으면 프록시 객체를 넣어주고 없으면 null을 넣음
    - 나중에 진짜 락커 필드에 액세스 할 때 쿼리가 나가며 지연로딩이된다.
    - 그런데 대상 테이블에 외래 키를 저장한다면 JPA가 멤버의 락커를 조회하는 상황에서 DB의 멤버 테이블만 조회해서는 모른다
    - 어차피 락커 테이블을 찾아가서 멤버가 있는지 확인해 봐야 알 수 있는 것
    - 어차피 쿼리가 나간다는 이야기는 프록시를 만들 필요가 없다는 이야기.

### 다대다
- 관계형 데이터베이스는 정규화된 테이블 2개로 다대다 관계를 표현할 수 없음
- 연결 테이블을 추가해서 일대다, 다대일 관계로 풀어내야 함
- 객체는 컬렉션을 이용한 다대다 관계를 맺을 수 있지만 테이블은 불가능!

### jpa 제공 @ManyToMany를 이용한 다대다는 사용을 권장하지 않는다(쓰지마라!)
- @ManyToMany 어노테이션과 @JoinTable로 연결 테이블을 지정하여 사용할 수 있지만 연결 테이블에 다른 데이터가 비집고 들어갈 수 없다
- 확장에 닫힌다

### 다대다 한계 극복
- 연결 테이블 용 엔티티를 추가 (연결 테이블을 엔티티로 승격)
</div>
</details>



<details>
<summary>05. 고급 매핑 </summary>
<div markdown="1">

### 상속관계 매핑
- 관계형 데이터베이스는 상속 관계 없음
- 슈퍼 타입과 서브 타입 관계라는 모델링 기법이 객체 상속과 유사하긴 함
- 상속관계 매핑: 객체의 상속 구조와 DB의 슈퍼타입 서브타입 관계를 매핑
- 슈퍼타입 서브타입 논리 모델을 실제 물리 모델로 구현하는 방법
  - 조인 전략
  - 단일 테이블 전략
  - 구현 클래스마다 테이블 전략

### 조인 전략
![img_12.png](imgs/img_12.png)
- 아이템을 상속하는 클래스의 테이블과 조인하는 전략
- 장점
  - 테이블이 정규화된다.
  - 외래 키 참조 무결성 제약조건 활용 가능
  - 저장공간 효율화
- 단점 
  - 조회시 조인을 많이 사용, 성능 저하
  - 조회 쿼리가 복잡
  - 데이터 저장시 INSERT SQL 두번 호출

### 단일 테이블 전략
![img_13.png](imgs/img_13.png)
- 상속하는 클래스의 모든 컬럼을 하나의 테이블에 다 때려 넣고 타입에 맞는 컬럼만 뽑아 쓰는 전략
- 장점
  - 조인이 필요 없음으로 조회 성능 빠름
  - 조회 쿼리 단순
- 단점 
  - 자식 엔티티가 매핑한 컬럼은 모두 null이 허용된다
  - 단일 테이블에 모든 것을 저장함으로 테이블이 커질 수 있고 상황에 따라서 조회 성능이 오히려 더 느려질 수도 있다

### 구현 클래스마다 테이블 전략
![img_14.png](imgs/img_14.png)
- 부모 클래스에서 필요한 컬럼을 하위 클래스에 모두 재정의 하는 것 
- 이건 걍 쓰지마라
- 장점 
  - 서브 타입을 명확하게 구분해서 처리할 때 효과적
  - not null 제약조건 사용 가능
- 단점
  - 여러 자식 테이블을 함께 조회할 때 성능이 느림(UNION SQL 필요)
  - 자식 테이블을 통합해서 쿼리하기 어려움

### @MappedSuperclass
- 공통 매핑 정보가 필요할 때 사용할 수 있다
- 테이블이 생성되는 것이 아니라 속성만을 상속하도록 하는 기능
- 부모 클래스를 상속 받는 자식 클래스에 매핑 정보만 제공
- 추상 클래스 권장
- 테이블과 관계 없고, 단순히 엔티티가 공통으로 사용하는 매핑 정보를 모으는 역할


</div>
</details>




<details>
<summary>06. 프록시와 연관관계 관리 </summary>
<div markdown="1">

### 프록시
- Member를 조회할 때 Team도 함께 조회해야 할까?
- Team과 관련된 필드를 조회하지 않는다면 불 필요 없음
- 그럼에도 member를 find 할 때 Team을 가져온다면 불필요하다고 볼 수 있음
- 이를 위해 나온 개념이 프록시
- 데이터베이스 조회를 미루는 가짜 엔티티 객체를 조회할 수 있는거시다

### 프록시 특징
- 실제 클래스를 상속 받아서 만들어짐
- 실제 클래스와 겉 모양이 같다
- 사용하는 입장에서는 진짜 객체인지 프록시 객체인지 구분하지 않고 사용 가능
- 프록시 객체는 실제 객체의 참조를 보관
- 프록시 객체를 호출하면 프록시 객체는 실제 객체의 메소드 호출
- ![img_15.png](imgs/img_15.png)
- ![img_16.png](imgs/img_16.png)
- 프록시 객체는 처음 사용할 때 한 번만 초기화
- 프록시 객체를 초기화 할 때 프록시 객체가 실제 엔티티로 바뀌는 것이 아님 target 필드가 실제 엔티티의 참조값으로 초기화 되는 것
- 프록시 객체는 원본 엔티티를 상속받음 따라서 타입 체크 시 주의해야 함
  - 프록시 클래스는 hibernateProxy블라블라. 엔티티 클래스와 다르기에 타입 체크 시 명심해야 한다
  - '=='을 사용하지 말고 instanceof를 사용해랑
- 영속성 컨텍스트에 찾는 엔티티가 이미 있으면 em.getReference()를 호출해도 실제 엔티티 반환
  - 반대로 프록시가 이미 영속성 컨텍스트내에 존재할 경우 em.find를 해도 프록시가 반환된다.
  - jpa는 같은 트랜잭션 내에서 a == a를 보장하기 위해 꽤나 노력하는 듯
  - 이를 위한 빌드업인가 싶다. 
- 영속성 컨텍스트의 도움을 받을 수 없는 준영속 상태일 때 프록시를 초기화하고자 하면 문제 발생! 
  - 프록시도 영속성 컨텍스트에서 관리되고 있어야 lazyInit의 이점을 누릴 수 있다. 
  - LazyInitializationException이 떠지면 오늘의 강의를 떠올리자! 

### 지연 로딩
- 연관관계에서 지연 로딩 LAZY를 사용하면 Member를 조회할 때 Team객체를 프록시 객체로 설정할 수 있다

### 즉시 로딩
- EAGER를 사용하면 Member를 조회할 때 Team 객체를 즉시 조회하여 load한다.

### 프록시와 즉시 로딩 주의
- 실무에선 지연 로딩으로 쳐발쳐발하자
- 즉시 로딩을 적용하면 예상하지 못한 SQL이 발생할 수 있다
- 즉시 로딩은 JPQL에서 N+1 문제를 일으킨다!
  - 하나의 쿼리가 N개의 쿼리를 추가로 만들어낼 수 있다는 것
- ManyToOne, OneToOne은 기본이 즉시 로딩임으로 명시적으로 LAZY로 설정하자
- ToMany는 기본이 지연 로딩이다
- 이론적으로는 자주 사용되면 즉시 로딩을 사용하고 가끔 사용하면 지연 로딩이 좋지만 무조건 지연 로딩을 사용하고 자주 사용되는 부분에 대해서는 페치 조인과 같은 해결책을 사용하도록 하자

### 영속성 전이: CASCADE
- 특정 엔티티를 영속 상태로 만들 때 연관된 엔티티도 함께 영속 상태로 만들고 싶은 경우 사용
- 영속성 전이는 연관관계를 매핑하는 것과 아무런 관련이 없다
- 엔티티를 영속화할 때 연관된 엔티티도 함께 영속화 하는 편리함을 제공할 뿐

### CASCADE의 종류
- ALL: 모두 적용
- PERSIST: 영속 적용
- REMOVE: 삭제 적용

### 고아 객체
- 부모 엔티티와 연관관계가 끊어진 자식 엔티티를 얘기하는 것
- 고아 객체 제거는 orphanRemoval = true로 가능하다
- ![img_17.png](imgs/img_17.png)
- 위와 같이 부모가 자식을 버리고 orphanremoval이 걸려 있다면 DELETE 쿼리가 자동으로 나간다.

### 주의 사항
- 고아 객체든 CASCADE든 특정 엔티티가 개인 소유할 경우, 그리고 parent와 child의 라이프 사이클이 유사한 경우 사용하는 것이 좋다.
- 상태 전이의 propagation을 충분히 고려해야 한다는 뜻!
- 다른 곳에서 child를 또 소유하고 있다면 갑자기 사라지는 불상사 발생 가능..

### 영속성 전이 + 고아 객체, 생명주기
- CascadeType.ALL + orphanRemoval=true
- 두 옵션을 모두 활성화 하면 부모 엔티티를 통해서 자식의 생명 주기를 관리할 수 있음
- CascadeType.REMOVE 와 orphanRemoval=true는 다르다
  - cascade는 부모 엔티티 삭제 -> 자식 엔티티 삭제
  - orphanRemoval=true는 고아객체 자동 삭제


</div>
</details>

<details>
<summary>07. 값 타입 </summary>
<div markdown="1">

### JPA의 데이터 타입 분류

- 엔티티 타입
  - @Entity로 정의하는 객체
  - 데이터가 변해도 '식별자'로 지속해서 추적 가능
  - ex) 회원 엔티티의 키나 나이 값을 변경해도 식별자로 인식 가능! 
- 값 타입
  - int, Integer, String처럼 단순히 값으로 사용하는 자바 기본 타입이나 객체
  - 식별자가 없고 값만 있음으로 추적 불가!
  - int a = 10;, int b =a 인 경우 a의 값을 변경해도 b의 값은 바뀌지 않는다. 값! 이기 때문

### 값 타입 분류
- 값 타입은 다시 다음으로 구분된다.
  - 기본값 타입
    - 자바 기본 타입(primitive)
      - int, double 등등
    - Wrapper class
    - String 
  - 임베디드 타입 (복합 값 타입)
  - 컬렉션 값 타입

### 기본 값 타입
- 생명주기를 엔티티에 의존
  - 회원을 삭제하면 이름, 나이 필드도 함께 삭제된다.
- 값 타입은 공유하면 안된다. (공유 되지도 않고)
  - 회원 이름을 변경했는데 다른 회원의 이름도 함께 변경되면 안됨
  - primitive 타입은 항상 값을 복사하기 때문에 다른 객체로의 side effect가 없긴 하다.
  - Wrapper 클래스는 참조를 사용하기에 주의를 해야 할 것 같지만 공유가 가능함에도 변경을 할 수 있는 방법이 없기에 side effect의 여지가 없음

### 임베디드 타입
- 새로운 값 타입을 직접 정의한 것
- 주로 기본 값 타입을 모아서 만들어서 복합 값 타입이라고도 함
- spoot-taxi 프로젝트 Location으로 미리 경험해 본 바 있다 (위도,경도)

### 임베디드 타입 사용 법
- @Embeddable: 값 타입을 정의하는 곳에 표시
- @Embedded: 값 타입을 사용하는 곳에 표시
- 기본 생성자 필수
- 한 곳에만 어노테이션 붙여도 사용 가능할 텐데 양쪽에 쓰는 것을 권장!

### 임베디드 타입의 장점
- 재사용 
- 높은 응집도 
- 객체 지향적 설계 (추가적인 메서드 필요할 때 관심사 분리 잘 할 수 있다.)
- 값 타입이기에 엔티티의 생명주기에 의존할 수 있다.

### 임베디드 타입과 테이블 매핑
- 임베디드 타입은 엔티티의 값일 뿐!
- 테이블에는 컬럼이 모두 매핑되지만 엔티티레벨에서 객체를 사용할 수 있도록 하는 것
- 객체와 테이블을 세밀하게 매핑하는 것을 가능하게 한다.

### 임베디드 타입과 연관관계
- ![img_18.png](imgs/img_18.png)
- Address (임베디드) 타입은 ZipCode (임베디드)를 가질 수 있다.
- 그런데 임베디드 타입인 PhoneNumber에서 엔티티를 참조하고 있는 경우는 어떻게 될까?
  - 별다른 조치 없이 임베디드 안에 엔티티를 쓸 수 있다. (외래키 그냥 가지고 있게 됨)

### @AttributeOverride
- 한 엔티티에서 같은 값 타입을 사용하면?
- ex) Address homeAddress, Address workAddress
  - 이런 경우 컬럼 명이 중복된다.
  - 오류 터짐
- AttributeOverrides, @AttributeOverride를 사용해서 컬럼 명 속성을 재정의 하면 같은 값 타입을 엔티티내에서 여러개 사용할 수 잇다

### 임베디드 타입과 null
- 임베디드 타입의 값 자체가 null이면 매핑한 컬럼 값은 모두 null이 된다. 

### 값 타입 공유 참조
- 임베디드 타입 같은 값 타입을 여러 엔티티에서 공유하면 위험함
- 회원1의 주소를 수정했는데 회원2의 주소가 수정되는 사이드 이펙트가 발생 가능하다!
- 따라서 값 타입의 실제 인스턴스를 공유하는 것은 위험 (주소값이 공유되면 안된다!)
- 대신 값(인스턴스)를 복사해서 사용해야 한다

### 객체 타입의 한계
- 위와 같이 인스턴스의 주소값이 공유되는 것을 막을 수 있는 방법이 없을까?
- 객체 타입은 참조 값을 직접 대입하는 것을 막을 방법이 없다.. 객체의 공유 참조는 피할 수 없는 것

### 불변 객체
- 참조를 막을 수는 없지만 객체 타입을 수정할 수 없도록 만들면 부작용을 차단 가능하다!
- 따라서 값 타입은 설계 시에 불변 객체로 설계해야 함 (생성 시점 이후 절대 값을 변경할 수 없는 객체!)
- 불변 객체로 설계하는 방법은 여러가지가 있지만 간단한 방법은 생성자로만 값을 설정하고 setter를 만들지 않은 형태
- 참고로 Integer, String은 자바가 제공하는 대표적인 불변 객체이다.

### 값 타입의 비교
- 값 타입: 인스턴스가 달라도 그 안에 값이 같으면 같은 것으로 봐야 한다.
- 하지만 클래스 간의 == 비교는 주소 값을 비교.. false가 나올 것이 자명하다
- 비교에는 동일성 (identity)비교와 동등성(equivalence) 비교가 있는데 값 타입에서는 동등성 비교를 해야 하는 것이다!
- 값 타입은 equals 메서드를 이용한 동등성 비교를 해야 한다!
- 값 타입의 equals 메서드를 적절히 재정의 하여 사용하장

### 값 타입 컬렉션
- 값 타입을 하나 이상 저장할 때 값 타입 컬렉션을 사용한다
- @ElemnetCollection(값 타입 컬렉션임을 알린다), @CollectionTable(생성될 테이블에 대한 정보를 알린다) 사용
- 데이터베이스는 컬렉션을 같은 테이블에 저장할 수 없기에 컬렉션을 저장하기 위한 별도의 테이블이 필요하다

### 값 타입 컬렉션 저장
- 멤버가 favoriteFood라는 String 값 타입 컬렉션을 가지고 있는 경우를 생각해보자
- 컬렉션에 값 타입을 추가할 때는 다음의 코드로 충분하다
```java
  member.getFavoriteFoods().add("치킨");
```
- 유의 깊게 봐야 할 점이 있는데 값 타입 컬렉션 매핑을 담당하는 테이블에 별도의 작업 없이 CascadeType.ALL이 걸려있는 것 처럼 동작한 다는 것이다.

### 값 타입 조회
- 값 타입 컬렉션을 포함하고 있는 member를 조회할 경우 값 타입에 대한 조회는 지연 로딩 전략이 디폴트이다.
- 멤버를 조회해도 값 타입 관련한 추가 쿼리가 없는 것을 예제로 확인했다
- 값 타입 컬렉션은 영속성 전이 + 고아 객체 기능을 필수로 가진다고 볼 수 있다

### 값 타입 컬렉션의 제약사항
- 값 타입은 엔티티와 다르게 식별자 개념이 없다.
- 값은 변경하면 추적이 어렵다.
- 값 타입 컬렉션에 변경 사항이 발생하면, 주인 엔티티와 연관된 모든 데이터를 삭제하고, 값 타입 컬렉션에 있는 현재 값을 모두 다시 저장한다. 
- 값 타입 컬렉션을 매핑하는 테이블은 모든 컬럼을 묶어서 기본 키를 구성해야 함
- 이쯤 되면 이상함을 눈치 채고 쓰지 말아야 한다. 전부 지우고 다시 쓰다니...

### 값 타입 컬렉션 대안
- 실무에서는 상황에 따라 값 타입 컬렉션 대신에 일대다 관계를 고려하라
- 일대다 관계를 위한 엔티티를 만들고 여기에서 값 타입을 사용
- 영속성 전이, 고아 객체 제거를 통해 값 타입 컬렉션 처럼 사용 가능하다
  - 영속성 전이와 고아 객체 제거를 함께 사용할 경우 부모 엔티티가 자식 엔티티의 생명주기를 관리할 수 있다고 저번 강의에서 배운바 있다.


</div>
</details>




<details>
<summary>08. 객체지향 쿼리 언어 </summary>
<div markdown="1">

### JPA 제공, 다양한 쿼리 방법
- JPQL
- JPA Criteria
- QueryDSL
- 네이티브 SQL
- JDBC API 직접 사용, MyBatis, SpringJdbcTemplate 사용

### JPQL
- JPA를 사용하면 엔티티 객체를 중심으로 개발하게 된다.
- 문제는 검색 쿼리
- 검색을 할 때도 테이블이 아닌 객체를 대상으로 검색 가능하게 하는 것이 JPQL
- 원래 DB는 SQL을 소비한다. 
- 그렇다면 JPQL은 모든 DB 데이터를 객체로 변환해서 검색을 가능하게 하는가?? NO! 종국에는 JPQL이 SQL로 번역되어 실행된다
- JPQL은 SQL 문법과 유사
![img_19.png](imgs/img_19.png)
- jpql은 동적 쿼리를 만들어 내기 어렵다는 단점이 있다(분기로 나누어 쿼리 스트링을 잘라내고 덧붙이고 할 수는 있지만 번거롭다)
- 동적인 쿼리를 쉽게 생성하기 위해 아래의 criteria와 queryDSL 방법이 있다

### Criteria
![img_20.png](imgs/img_20.png)
- 문자가 아닌 자바코드로 JPQL을 작성할 수 있다
- JPA 공식 기능이지만 너무 복잡하고 실용성이 없어 범용되지 않는 분위기 인듯
- 이대신에 QueryDSL을 사용하는 것이 권장된다.

### QueryDSL
- 문자가 아닌 자바 코드로 JPQL을 작성할 수 있다는 점에서 Criteria와 동일
- JPQL 빌더 역할을 하는 것
- 자바 코드로 이루어짐으로 컴파일 시점에 문법 오류를 찾을 수 있고 동적 쿼리를 작성하기 편하다!
- 사용 권장!
![img_22.png](imgs/img_22.png)
### Native SQL
- JPA가 제공하는 SQL을 직접 사용하는 기능
- JPQL로 해결할 수 없는 특정 데이터베이스에 의존적인 기능이 필요한 경우 사용된다. (ex 오라클 CONNECT BY)
![img_21.png](imgs/img_21.png)

### JPQL 문법과 기능
- JPQL은 객체지향 쿼리 언어다.
- 따라서 테이블을 대상으로 쿼리 하는 것이 아니라 엔티티 객체를 대상으로 쿼리한다.
- JPQL은 SQL을 추상화해서 특정데이터베이스 SQL에 의존하지 않는다.
- JPQL은 결국 SQL로 변환된다.
- ![img_24.png](imgs/img_24.png)
- 집합과 정렬 같은 SQL ANSI 표준 function을 지원한다.

### JPQL 문법
![img_23.png](imgs/img_23.png)
- 엔티티와 속성은 대소문자 구분 O
- JPQL 키워드는 대소문자 구분 X
- 엔티티 이름 사용! (테이블 이름 아님)

### TypeQuery와 Query
- TypeQuery: 반환 타입이 명확할 때 사용
- ![img_25.png](imgs/img_25.png)
- Query: 반환 타입이 명확하지 않을 때 사용
- ![img_26.png](imgs/img_26.png)
- 참고로 query를 저렇게 초기화하고 쓰기보다는 em.create**하고 메서드의 체인으로 이어나가는 것이 일반적

### 결과 조회 API
- query.getResultList(): 결과가 하나 이상일 때 리스트 반환
  - 결과가 없으면 빈 리스트를 반환함으로 null에 대한 고민은 할 필요 X
- query.getSingleResult(): 결과가 정확히 하나일 때 단일 객체 반환
  - 결과가 없으면: NoResultException
  - 결과가 둘 이상이면: NonUniqueResultException
  - 이걸 try catch로 감싸기는 조금...
  - 스프링 데이터 jpa에서는 try catch로 감싼 버전의 메서드가 있는데 그걸 쓰는듯? (없으면 null을 주도록 설정되어 있다고 함)

### 파라미터(검색 조건) 바인딩
- 이름 기준 
![img_27.png](imgs/img_27.png)
- 위치 기준
![img_28.png](imgs/img_28.png)
- 위치 기준은 쓰지 마라 

### 프로젝션
- SELECT 절에 조회할 대상을 지정하는 것 
- 프로젝션 대상: 엔티티, 임베디드 타입, 스칼라 타입
- "SELECT m FROM Member m": 엔티티 프로젝션
- "SELECT m.team FROM Member m": 엔티티 프로젝션 
  - 멤버와 연관된 팀을 조인해서 가져온다.
  - 하지만 이와 같은 묵시적 조인보다는 명시적으로 조인해서 가져오는 것이 좋음
  - 항상 조인에는 튜닝의 여지가 있기 때문!
- "SELECT m.address FROM Member m": 임베디드 타입 프로젝션 
  - 스칼라 타입 프로젝션 하는 것 처럼 가져오면 된다. 임베디드 타입은 테이블이 없음으로 멤버를 통해서 조회할 것!
- "SELECT m.username, m.age FROM Member m": 스칼라 타입 프로젝션
  - DISTINCT를 통해 중복을 제거할 수 잇따

### 프로젝션 - 여러 값 조회
- "SELECT m.username, m.age FROM Member m"
- 위와 같이 복수의 컬럼을 조회할 경우 반환된 데이터를 어떻게 handling할 수 있을까?
1. Query 타입으로 조회 
   - TypedQuery가 아닌 걸로 조회한다는 뜻, Object가 조회된다.
2. Object[] 타입으로 조회
   - 권장되는 방법이 아니다. 받아온 데이터를 전부 다운 캐스팅 해줘야 한다..
3. new 명령어로 조회
   - 단순 값을 미리 정의한 DTO로 조회하는 방법이다.
   - "SELECT new jpabook.jpql.UserDto(m.username, m.age) FROM Member m"
   - 패키지 명을 포함한 전체 클래스 명을 입력하는 것으로 가능하다
   - 순서와 타입이 일치하는 생성자가 미리 필요하다.

### 페이징 
- 페이징이란? 데이터베이스에서 정해진 개수와 시작지점을 통해 특정 영역의 데이터를 불러오는 것
- JPA에서는 페이징을 다음 두 API로 추상화 한다.
  - setFirstResult(int startPosition): 조회 시작 위치
  - setMaxResults(int maxResult): 조회할 데이터 수
- 원래는 이게 방언마다 굉장히 복잡한 쿼리를 필요로 함 특히 오라클은 3 depth를 통해 페이징을 구현하는데 다음처럼 복잡하다.
- ![img_29.png](imgs/img_29.png)
- JPA에서는 두가지 api로 충분!

### 조인
- 내부 조인: SELECT m FROM Member m [INNER] JOIN m.team t
  - 내부 조인이란? 동일한 값이 있는 (조인 조건을 만족하는) 행만을 반환한다. 교집합을 반환!
- 외부 조인: SELECT m FROM Member m LEFT [OUTER] JOIN m.team t
  - 외부 조인이란? 테이블 두개를 조인하되 조인의 대상이 되는 테이블에 값이 없을 경우 null로 채워서 반환 
- 세타 조인: SELECT COUNT(m) FROM Member m, Team t WHERE m.username = t.name
  - 세타 조인이란? cartesian product를 한 테이블에서 WHERE절을 만족하는 row들을 반환하는 것

### 조인 ON 절
1. 조인 대상 필터링
2. 연관관계 없는 엔티티 외부 조인
- 위의 두가지를 가능하게 하는 join ON 절 
- jpa 2.1부터 지원한다.

### 조인 대상 필터링 
- ex) 회원과 팀을 조인하면서, 팀 이름이 A인 팀만 조인
- JPQL: "SELECT m, t FROM Member m LEFT JOIN m.team t on t.name = 'A'"

### 연관관계 없는 엔티티 외부 조인
- ex) 회원의 이름과 팀의 이름이 같은 대상 외부 조인
- JPQL: "SELECT m, t FROM Member m LEFT JOIN Team t on m.username = t.name"

### 쿼리 안의 서브 쿼리
- 나이가 평균보다 많은 회원
  - select m from Member m
    where m.age > (select avg(m2.age) from Member m2)
- 한 건이라도 주문한 고객
  - select m from Member m
    where (select count(o) from Order o where m = o.member) > 0

### 서브 쿼리 지원 함수
- [NOT] EXISTS (subquery): 서브쿼리에 결과가 존재하면 참
  - {ALL | ANY | SOME} (subquery)
  - ALL 모두 만족하면 참
  - ANY, SOME: 같은 의미, 조건을 하나라도 만족하면 참
- [NOT] IN (subquery): 서브쿼리의 결과 중 하나라도 같은 것이 있으면 참

### 서브 쿼리 - 예제
- 팀 A 소속인 회원
  - select m from Member m
    where exists (select t from m.team t where t.name = ‘팀A')

- 전체 상품 각각의 재고보다 주문량이 많은 주문들
  - select o from Order o
    where o.orderAmount > ALL (select p.stockAmount from Product p)
- 어떤 팀이든 팀에 소속된 회원
  - select m from Member m
    where m.team = ANY (select t from Team t)

### JPA 서브 쿼리 한계
- JPA는 WHERE, HAVING 절에서만 서브 쿼리 사용 가능
- SELECT 절도 가능 (하이버네이트에서 지원)
- FROM 절의 서브 쿼리는 현재 JPQL에서 불가능!
  - 조인으로 풀 수 있으면 풀어서 해결하라

### 경로 표현식
- .(점)을 찍어 객체 그래프를 탐색하는 것이 경로 표현식이다. 
  - 객체 그래프란? 객체들 간의 복잡한 관계를 그래프라고 부른다. (서로 연관관계를 가지며 얽혀있는 객체들을 얘기하는 것)
- ![img_30.png](imgs/img_30.png)
- 위의 상태 필드, 단일 값 연관 필드, 컬렉션 값 연관 필드 모두 객체 그래프를 탐색한 경로 표현식이다

### 경로 표현식 특징
- 상태 필드(state field): 단순히 값을 저장하기 위한 필드 (ex: m.username)
  - 경로 탐색의 끝, 추가적 탐색 불가
- 연관 필드(association field): 연관관계를 위한 필드 
  - 단일 값 연관 필드: @~ToOne, 대상이 엔티티 (ex: m.team)
    - 묵시적 내부 조인 발생, 탐색 추가로 가능
  - 컬렉션 값 연관 필드: @~ToMany, 대상이 컬렉션 (ex: m.orders)
    - 묵시적 내부 조인 발생, 탐색 추가적으로 불가

### 경로 탐색을 사용한 묵시적 조인 시 주의 사항
- 항상 내부 조인이 일어난다. (외부 조인 불가)
- 컬렉션은 경로 탐색의 끝, 명시적 조인을 통해 별칭을 얻어 추가 탐색을 가능하게 할 수 있음
  - select t.members from Team t 탐색 불가
  - select m.탐색 from Team t join t.members m 탐색 가능 명시적  join으로 별칭 얻고 탐색 가능

### 권장 사항
- 가급적 묵시적 조인 대신에 명시적 조인을 사용하라
- 조인은 SQL 튜닝에 중요 포인트이다.
- 묵시적 조인은 조인이 일어나는 상황을 한눈에 파악하기 어려움


### 페치 조인 
- 페치 조인은 SQL의 조인 종류 중 하나가 아니다!
- JPQL에서 성능 최적화를 위해 제공하는 기능
- 연관된 엔티티나 컬렉션을 SQL 한 번에 함께 조회하는 기능
- join fetch 명령어를 사용하여 사용가능
- 페치 조인::= [ LEFT [OUTER] | INNER ] JOIN FETCH 조인경로

### 엔티티 페치 조인
- 회원을 조회하면서 연관된 팀도 함께 조회(SQL 한번에)
- SQL을 보면 회원 뿐만 아니라 Team도 함께 SELECT하는 것을 확인 가능
- ![img_31.png](imgs/img_31.png)
- ![img_32.png](imgs/img_32.png)

### 페치 조인 사용 코드 
```java 
String jpql = "select m from Member m join fetch m.team";
List<Member> members = em.createQuery(jpql, Member.class)
 .getResultList();
for (Member member : members) {
 //페치 조인으로 회원과 팀을 함께 조회해서 지연 로딩X
 System.out.println("username = " + member.getUsername() + ", " +
 "teamName = " + member.getTeam().name()); 
}
```
### 페치 조인과 EAGER와 LAZY 모두 다르게 동작함을 알아라!
- 즉시 로딩(EARGR로 설정)
1. 멤버 전체를 조회하기 위해 JPQL 실행 select m from member m

2. JPQL은 EAGER와 무관하게 SQL로 그대로 번역 -> select m.* from member

3. JPQL 결과가 member만 조회하고, team은 조회하지 않음

4. member와 team이 즉시 로딩으로 설정되어 있기 때문에 연관된 팀을 각각 쿼리를 날려서 추가 조회 (N+1)

- 지연 로딩(LAZY로 설정)

1. 멤버 전체를 조회하기 위해 JPQL 실행 select m from member m

2. JPQL은 EAGER와 무관하게 SQL로 그대로 번역 -> select m.* from member

3. JPQL 결과가 member만 조회하고, team은 조회하지 않음

4. member와 team이 지연 로딩으로 설정되어 있기 때문에 가짜 프록시 객체를 넣어두고, 실제 회원은 팀은 조회하지 않음

5. 실제 team을 사용하는 시점에 쿼리를 날려서 각각 조회(N+1)

- fetch join 또는 엔티티 그래프(EAGER, LAZY 상관 없음)

1. 멤버와 팀을 한번에 조회하기 위해 JPQL+fetch join 실행 select m from member m join fetch m.team

2. JPQL에서 fetch join을 사용했으므로 SQL은 멤버와 팀을 한 쿼리로 조회 -> select m.*, t.* from member join team ...

3. JPQL 결과가 member와 team을 한꺼번에 조회함

4. member와 team이 fetch join으로 한번에 조회되었으므로 N+1 문제가 발생하지 않음
### 참고 
- https://www.inflearn.com/questions/39516/fetch-%EC%A1%B0%EC%9D%B8-%EC%97%94%ED%8B%B0%ED%8B%B0-%EA%B7%B8%EB%9E%98%ED%94%84-%EC%A7%88%EB%AC%B8%EC%9E%85%EB%8B%88%EB%8B%A4

### 컬렉션 페치 조인
- 일대다 관계, 컬렉션 페치 조인
- ![img_33.png](imgs/img_33.png)
- ![img_34.png](imgs/img_34.png)
- Team입장에서 조인을 하면 위 그림처럼 데이터가 뻥튀기 된다! 
  - 팀A에 속한 멤버가 두명이다 조인 결과 테이블이 위의 그림처럼 되는 것
  - 살펴보면 팀A가 두번 나오는 것을 확인 가능하다.
  - result도 두개가 나온다 (줄일 수 있긴하다 DISTINCT라던지 하지만 TABLE레벨에서는 저렇게 가져오는 것이 맞기에 어떻게 사용할지는 개발자에게 맡긴 것)
  - 팀A에 몇명이 속한지는 jpa는 사전파악이 불가 결과를 줄줄 가져오는 것을 기억하자 


### 컬렉션 페치 조인 사용 코드
```java
String jpql = "select t from Team t join fetch t.members where t.name = '팀A'"
List<Team> teams = em.createQuery(jpql, Team.class).getResultList();
for(Team team : teams) {
 System.out.println("teamname = " + team.getName() + ", team = " + team);
 for (Member member : team.getMembers()) {
 //페치 조인으로 팀과 회원을 함께 조회해서 지연 로딩 발생 안함
 System.out.println(“-> username = " + member.getUsername()+ ", member = " + member);
 }
}
```

### 페치 조인과 DISTINCT
- SQL의 DISTINCT는 중복된 결과를 제거하는 명령
- JPQL의 DISTINCT 2가지 기능 제공
  - SQL에 DISTINCT를 추가
  - 애플리케이션에서 엔티티 중복을 제거 
  - DISTINCT를 SQL에 걸고 애플리케이션에 반환된 데이터의 중복까지 검토해주는 것이다.
- select distinct t
  from Team t join fetch t.members
  where t.name = ‘팀A
- 위와 같이 사용하면 SQL에 DISTINCT를 추가하지만 SQL에 추가된 DISTINCT만으로는 중복 결과를 완전히 지워내지 않는다.
  - SQL의 DISTINCT는 row의 모든 컬럼이 완전히 똑같아야 지워낸다.
  - 하지만 JPQL에서 사용된 DISTINCT이기에 어플리케이션 레벨에서 중복된 엔티티가 지워진다!
  - ![img_35.png](imgs/img_35.png)
  - 참고: 하이버네이트 6부터는 DISTINCT 명령어를 사용하지 않아도 애플리케이션에서 중복 제거가 자동으로 적용된다.

### 페치 조인과 일반 조인의 차이
- 페치 조인을 사용할 때만 연관된 엔티티도 함께 한방 조회
- 페치 조인은 객체 그래프를 SQL 한번에 조회하는 개념
- 그냥 조인은 엔티티를 프로젝션하면 연관된 것을 가져오지 않는다. (SELECT 절에 지정한 것만 프로젝트 할 뿐 )

### 페치 조인의 특징과 한계 
- 페치 조인 대상에는 별칭을 줄 수 없다. (객체 그래프는 데이터를 거르면서 조회하는 것이 아니라 다 조회해와야 한다)
- 둘 이상의 컬렉션은 페치 조인할 수 없다. (데이터 뻥튀기가 너무 심하기에 막은 것)
- 컬렉션을 페치 조인하면 페이징 API를 사용할 수 없다.
  - 단일 값 연관 필드들은 페치 조인해도 페이징 가능 (데이터 뻥튀기가 안되니까)
  - 일대다에서는 하이버네트가 경고 로그를 남기고 메모리에서 페이징(매우 위험)
    - 팀A 회원 1,2인 경우 페이징을 하면 팀A 회원1 이 하나의 row를 오해할 여지가 충분하다 (팀A는 회원1만 가지고 있다 등등)
    - DISTINCT는 안되나? -> 페이징은 지극히 테이블 중심의 API이기 때문에 안된다. 
    - 정 페이징을 하고 싶으면? 다대일로 방향을 뒤집어서 쿼리를 쓰거나 일대다인 상태에서 페치 조인 하지 않고 조회한 것을 배치 사이즈와 연결하여 N+1 문제를 완화할 수 있음
    - @BatchSize(): 글로벌 셋팅으로 가져갈 수 도 있다. 
    - 배치 사이즈는 한번 끌어올 때 배치로 끌어와서 N+1문제를 완화하는 것! (레이지 로딩을 끌고 올 때 나와 관련된 로딩만 하지 않고 List에 담긴 팀을 inquery로 배치 사이즈 만큼 가져오는 것 ) 
- 연관된 엔티티들을 SQL 한번으로 조회하는 페치 조인
- 엔티티에 직접 적용하는 글로벌 로딩 전략보다 우선함
- 실무에서 글로벌 로딩 전략은 모두 지연로딩으로 잡고 최적화가 필요한 곳은 페치 조인을 적용한다.

### 페치 조인 - 정리
- 모든 것을 페치 조인으로 해결할 수는 없음
- 페치 조인은 객체 그래프를 유지할 때 사용하면 효과적
- 여러 테이블을 조인해서 엔티티가 가진 모양이 아닌 전혀 다른 결과를 내야 하면, 페치 조인 보다는 일반 조인을 사용하고 필요한 데이터들만 조회해서 DTO로 반환하는 것이 효과적

### JPQL - 다형성 쿼리
- type
  - 조회 대상을 특정 자식으로 한정
  - "select i from Item i where type(i) In(Book, Movie)"
- treat
  - 자바의 타입 캐스팅과 유사, 상속 구조에서 부모 타입을 특정 자식 타입으로 다룰 때 사용
  - FROM WHERE SELECT 사용
  - "select i from Item i where treat(i as Book).author = 'kim'"

### JPQL - 엔티티 직접 사용
- JPQL에서 엔티티를 직접 사용하면 SQL에서 해당 엔티티의 기본 키 값을 사용
- ![img_36.png](imgs/img_36.png)
- 엔티티 자체를 파라미터로 전달하든 엔티티의 식별자를 직접 전달하든 기본 키 값이 사용된다 

### JPQL - Named 쿼리
- 미리 정의해서 이름을 부여해두고 사용하는 JPQL
- 정적 쿼리
- 어노테이션, XML에 정의 하여 사용할 수 있다
- 애플리케이션 로딩 시점에 초기화 후 재사용되기에 어플리케이션 로딩 시점에 쿼리를 검증해준다.
- 즉, 재사용성과 검증성에서 장점을 가지는 기능!
- Named 쿼리는 XML에 정의되어 있는 것이 항상 우선권을 가짐을 기억하자

### JPQL - 벌크 연산
- 재고가 10개 미만인 모든 상품의 가격을 10% 상승하려면?
- JPA 변경 감지 기능으로 실행하려면 너무 많은 SQL이 실행된다.
  1. 재고가 10개 미만인 상품을 리스트로 조회한다.
  2. 상품 에닡티의 가격을 10% 증가한다.
  3. 트랜잭션 커밋 시점에 변경감지가 동작한다.
  4. 변경된 데이터가 100건이라면 종국에 100번의 UPDATE SQL이 실행되게 된다.

### 벌크 연산 사용 예제
- 쿼리 한 번으로 여러 로우 변경 (엔티티)
- executeUpdate()의 결과는 영향받은 엔티티 수 반환
- UPDATE, DELETE 지원
- INSERT는 하이버네이트에서 지원
- ![img_37.png](imgs/img_37.png)

### 벌크 연산 주의 
- 벌크 연산은 영속성 컨텍스트를 무시하고 데이터베이스에 직접 쿼리
- 따라서 벌크 연산 후 영속성 컨텍스트 내의 데이터와 데이터베이스의 데이터의 싱크가 맞지 않는 경우가 생길 수 있다! 매우 위험
- 이를 해결하기 위해서는 다음의 두가지 방법 중 하나를 택할 수 있다.
  - 벌크 연산을 제일 먼저 실행
    - 영속성 컨텍스트 내에 데이터가 쌓이기 이전에 벌크 연산을 선조치 하는 방법이다.
  - 벌크 연산 수행 후 영속성 컨텍스트 초기화
    - 벌크 연산을 수행한 후 영속성 컨텍스트 내의 데이터를 초기화 하는 방법이다.
- 위 두가지 방법 중 하나를 사용하면 안전하게 벌크 연산을 이용 가능하다! 

</div>
</details>
