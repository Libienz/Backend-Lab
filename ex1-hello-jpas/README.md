

<details>
<summary>01. 영속성 컨텍스트 </summary>
<div markdown="1">

### 영속성 컨텍스트
- 엔티티를 영구 저장하는 환경

### 엔티티의 생명주기
- 비영속
  - (new/transient) 영속성 컨텍스트와 전혀 관계가 없는 새로운 상태
- 영속
  - 영속성 컨텍스트에 관리되는 상태
- 준영속
  - 영속성 컨텍스트에 저장되었다가 분리된 상태
- 삭제
  - 삭제된 상태 
  - em.remove(member) 객체 자체를 삭제

![img.png](imgs/img.png)

### 영속성 컨텍스트를 사용하여 얻는 이점
- 강의에서도 얘기했지만 항상 어떤 것과 어떤 것을 매핑하는 중간계층의 컨텍스트를 사용할 경우 크게 두 가지의 이점을 얻을 수 있다
1. buffered 작업
2. 캐시 이용
- 영속성 컨텍스트 역시 RDB와 객체 엔티티간의 매핑으로써 다음의 이점을 얻을 수 있다
  - 1차 캐시 
    - em.persist로 객체를 영속화 할 경우 em.find할 때 1차 캐시에서 조회할 수 있다.
    - DB connection과 반복되는 쿼리 작업을 을 줄일 수 있다.
    - 만약 em.find를 한경우 cache miss가 나면 DB에서 꺼내와서 1차 캐시에 객체를 담아 둔다.
  - 동일성 보장
    - Member a = em.find(Member.class, 1L);
    - Member b = em.find(Member.class, 1L);
    - a == b가 성립한다. 
    - 어려운 말로 1차 캐시로 반복 가능한 읽기 등급의 트랜잭션 격리 수준을 데이터베이스가 아닌 애플리케이션 차원에서 제공한다고 표현할 수 있다
  - 쓰기 지연
    - 트랜잭션을 지원하는 쓰기 지연
    - em.persist는 객체를 영속화 할 뿐 sql을 실행시키지 않는다.
    - 커밋하는 순간 데이터가 영구화 된다.
    - flush: 데이터베이스에 sql 저장소에 있는 쿼리들을 실행시켜 영속성 컨텍스트와 DB의 내용을 동기화
      - 다만 flush 후 커밋하지 않으면 트랜잭션 단위 roll back이 가능한 상태이다.
    ![img.png](img.png)
  - 변경 감지
    - 이전 실전편에서 데이터를 수정할 경우 memberA.setUsername("h");와 같이 수정하고 따로 persist 할 필요가 없는 것을 보았었다
    - 이와 같은 과정이 가능한 것은 영속성 컨텍스트에 엔티티와 스냅샷을 비교하는 과정이 있기 때문 
    ![img_1.png](img_1.png)
  - 지연 로딩
- 
</div>
</details>


<details>
<summary>02. 엔티티 매핑 </summary>
<div markdown="1">

### @Entitiy
- @Entity가 붙은 클래스는 jpa가 관리, 엔티티라 한다.
- 테이블과 객체를 매핑할 클래스에 @Entity를 붙여주면 된다.
- 어노테이션을 사용하기 위해서 기본 생성자 필수!(접근 제어는 public 혹은 protected)
- final 클래스, enum, interface, inner 클래스는 사용 불가
- 저장할 필드에 final 사용 X

### 데이터베이스 스키마 자동 생성
- DDL을 애플리케이션 실행 시점에 자동 생성
- propertiy 파일에 DDL 행동의 속성을 설정할 수 있는데 create, create-drop, update, validate, none과 같은 속성들이 있다 
- 운영 장비에는 절대 create, create-drop, update를 사용하지 말자 (전부 지워버리는 수가 있다)
- 개발 초기 단계는 create 또는 update
- 많은 개발자들이 모여서 사용하는 테스트 서버는 update 또는 validate
- 스테이징과 운영 서버는 validate 또는 none을 사용하자

### 필드와 컬럼 매핑
### @Column
  - name: 필드와 매핑할 테이블의 컬럼 이름
  - insertable, updatable: 등록, 변경 가능 여부
  - nullable: 컬럼에 유니크 제약조건을 걸 때 사용
  - columnDefinition: 데이터베이스 컬럼 정보를 직접 줄 수 있다. 
    - ex) varchar(100) default ‘EMPTY'
  - length: 문자 길이 제약 조건
  - precision, scale: bigDecimal 타입에서 사용 floating number의 정밀도와 scale 지정
### @Enumerated
  - 자바 enum 타입을 매핑할 때 사용
  - 두가지 ORDINAL과 STRING 이쓴ㄴ데 항상 STRING을 사용하도록 하자 
### @Temporal
  - 날짜 타입을 매핑할 떄 사용
  - but 충분히 높은 버젼의 hibernate을 사용하고 있다면 LocalDate, LocalDateTime을 @Temporal없이 사용 가능
### @Lob
  - 데이터베이스 BLOB, CLOB 타입과 매핑
  - 지정할 수 있는 속성 없음
  - 매핑하는 필드 타입이 문자면 CLOB 매핑, 나머지는 BLOB 매핑
### @Transient
  - 필드 매핑 X
  - 데이터베이스에 저장 X

### 기본 키 매핑 어노테이션

### @Id
- PK임을 알림
### @GeneratedValue
- 키를 자동 생성 하도록 설정
- Strategies
  - IDENTITY: 데이터베이스에 위임
    - DB에 넣을 때 null로 주고 DB에서 키를 알아서 생성하도록 위임한다
    - 다만 persist 시점에 영속성 컨텍스트에서 관리하기 위해 SQL을 flush시점이 아니더라도 persist 시점에 바로 푸쉬한다.  
    - 버퍼의 장점을 누리지 못하지만 생각보다 cardinal한 성능저하는 일어나지 않음
  - SEQUENCE: 데이터베이스 시퀀스 오브젝트 사용
    - 오라클에서 많이 사용
    - jpa가 시퀀스 값을 db로 부터 가져와서 메모리에 저장한다. 
    - 데이터 베이스에 call next value 쿼리를 보내어 시퀀스 오브젝트의 값을 가져온다
    - 시퀀스 값은 db에서 미리 정의 되어 있는 것이 IDENTITY와의 차이점 (가져온 후에 영속성 컨텍스트에 저장하는 것도 차이점)
    - 시퀀스 제네레이터는 커스텀 가능
      - 특히 주의 깊게 볼 속성은 allocationSize
      - allocationSize = 50(default)으로 하면 DB에서 시퀀스를 가져올 때 50개를 가져와서 로컬 메모리에 저장할 수 있다
      - 1번 할때마다 네트워크를 타면 부담스러우니 allocationSize이용하면 성능 최적화를 이룰 수 있다
      - 이론적으로는 사이즈가 크면 클수록 좋지만 웹서버를 내리는 시점에 id 값의 구멍이 생길 수 있다 (굳이 구멍 생겨도 문제는 없지만)
  - TABLE: 키 생성용 테이블 사용, 모든 DB에서 사용
    - 테이블을 직접사용하다 보니 락도 걸릴 수 있고 성능이 떨어질 수 있음
    - 잘 사용되는 매핑 전략은 아님
  - AUTO: 방언에 따라 자동 지정, default
- 결론은 뭘쓰냐!? 
  - 기본 키는 null이면 안되고 유일해야 하고 변하면 안된다.(서비스의 요소를 pk로 끌어오지 말자)
  - 권장: Long형 + 대체키 + 키 생성전략 사용(AUTO_INCREMENT나 SEQUENCE 전략 사용)
- 

</div>
</details>



<details>
<summary>03. 연관관계 매핑 </summary>
<div markdown="1">

### 데이터 중심 연관관계 모델링
- 회원과 팀이 있고 회원과 팀이 다대일 관계를 맺는 경우를 생각해보자
- 회원 엔티티에 teamId 속성을 두어 객체 간의 연관관계를 맺었다면 이는 객체를 테이블에 맞추어 모델링 한 것
  - 참조 대신에 외래 키를 그대로 사용한 것이다. (실제로 테이블이 이러한 구성)
  - 이는 객체 지향적인 방법은 아니다. 
- 객체를 테이블에 맞추어 데이터 중심으로 모델링 하면, 협력 관계를 만들 수 없다. 
  - 테이블은 외래 키로 조인을 사용해서 연관된 테이블을 찾겠지만 객체는 참조를 이용해서 연관된 객체를 찾아야 하기 때문
  - 테이블과 객체 사이에는 이런 큰 간격이 있다

### 객체 지향 모델링
- 회원과 팀이 있고 회원과 팀이 다대일 관계를 맺는 경우 Member 클래스의 필드에 Team 필드가 존재한다면 Member객체는 참조값을 이용해 연관관계를 맺게 된다.
- 객체 지향적으로 모델링 하면 객체의 참조와 테이블의 외래키를 매핑하게 되는 것이다.
- 결국 jpa가 연관관계 매핑에서 객체와 테이블의 간극을 매핑하는 것

### 단방향 연관관계와 양방향 연관관계
### 단방향
![img_2.png](img_2.png)
- 멤버는 팀의 참조값을 가지고 있어 연관관계를 맺지만 팀은 Member로 향하는 연관관계를 가지고 있지 않다. 

### 양방향 
![img_3.png](img_3.png)
- 멤버에서 팀으로의 연관관계뿐만 아니라 역방향 연관관계 역시 가지고 있다 

### 객체와 테이블이 관계를 맺는 차이
- 객체와 테이블간의 연관관계를 맺는 차이를 이해해야 jpa에서 연관관계를 매핑하는 블랙박스를 이해할 수 있다.
- 객체의 양방향 관계는 사실 양방향 관계가 아니라 서로 다른 단방향 관계 2개다 (단방향에서 역방향을 추가해준 것일 뿐)
- 반면 테이블은 외래 키 하나로 두 테이블의 연관관계를 관리하는데 이는 양방향 연관관계이다.(양쪽으로 모두 join 가능)
- 따라서 테이블은 두 테이블 중 하나로 외래키를 관리해야 한다. 
- 외래키를 가지고 있는 쪽은 연관관계의 주인이 되는데 객체의 연관관계를 매핑하려면 이러한 특성에 주목해야 함 

### 연관관계의 주인
- 객체의 두 관계 중 하나를 연관관계의 주인으로 지정해야 한다.
- 연관관계의 주인만이 외래 키를 관리
- 주인이 아닌쪽은 읽기만 가능
- 주인은 mappedBy 속성 사용X
- 주인이 아니면 mappedBy 속성으로 주인 지정
- 객체에서 연관관계의 주인은 외래키가 있는 곳으로 설정해야 함 (de facto standard)

### 양방향 매핑 시 가장 많이 하는 실수
![img_4.png](img_4.png)
- 연관관계의 주인이 아닌 1쪽 엔티티에만 추가를 해준 후에 member 테이블의 TEAM_ID를 살펴보면 null로 지정되어 있다.
- 연관 관계의 주인은 연관 관계를 갖는 두 객체 사이에서 조회,저장,수정,삭제를 모두 할 수 있지만 연관관계의 주인이 아니면 조회만 가능하다. 
  ### 왜??
    - 멤버에서 팀을 바꾸든지 팀에서 멤버를 바꾸든지 객체 입장에서는 두 방법 다 맞는 방법이긴 하다
    - 하지만 객체에서 이렇게 양방향 연관 관계의 관리 포인트가 두 곳일 때는 테이블과 매핑을 담당하는 JPA에게 혼란을 주게 됨
    - 그렇기 때문에 두 객체 사이의 연관 관계의 주인을 정해서 관리 포인트를 한 곳으로 좁혀 주는 것이 mappedBy인 것! 
  ### 그렇다면 연관관계의 주인만 제어하면 되나?
  - 데이터베이스만 생각했을 때는 맞겠지만 객체를 생각해보면 둘 다 변경해주는 것이 좋다. 두 참조를 사용하는 순수한 두 객체의 데이터 동기화를 위한 것임

### 다음을 권장한다
- 단방향 매핑만으로도 사실 연관관계 매핑은 완료 된 것
- 양방향 매핑은 반대 방향으로 조회(객체 그래프 탐색) 기능이 추가 된 것 뿐
- 단방향 매핑을 잘 수행하는 것이 중요하고 양방향은 필요할 때 추가해도 된다.
- 사실 단방향이 깔끔하다.
  - 문맥상으로도 주문서를 보고 주문에 관한 정보를 찾는 것이 일반적
  - 즉 중간 테이블을 통해 쿼리를 시작하는 것이 일반적이지 멤버에서 getOrders하는 것은 설계 오류라고 볼 수 있을 정도
  - 관심사를 끊어내는 것이 더 깔끔하고 simple하다!





</div>
</details>