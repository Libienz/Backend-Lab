# JAVA_Spring_Core

<details>
<summary>01 객체 지향 설계와 스프링 </summary>
<div markdown="1">

## 자바 진영의 추운 겨울과 스프링의 탄생

### EJB 
Enterprise Java Beans 자바 진영의 겨울 ..EJB를 주요 기술로써 개발할 때 여러가지 힘든 점이 많았다고 함

### Spring
EJB 컨테이너를 대체하며 현재의 표준 기술로 자리잡음

### Hibernate
EJB 엔티티빈 기술을 대체 하며 JPA 새로운 표준 정의
 

## 스프링이란??

### 스프링 프레임워크
핵심기술 : 스프링 DI 컨테이너, AOP, 이벤트 등등..

웹 기술 : 스프링 MVC, 스프링 WebFlux

데이터 접근 기술 : 트랜잭션, JDBC, ORM 지원, XML 지원

### 스프링 부트

스프링을 편리하게 사용할 수 있도록 지원, 최근에는 기본으로 사용

Tomcat 같은 웹 서버 내장, 별도의 웹 서버 설치하지 않아도 됨 

### 스프링의 핵심
스프링은 자바 언어 기반의 프레임워크, 자바 언어의 가장 큰 특징은 객체 지향 언어라는 점
스프링은 객체 지향 언어가 가진 강력한 특징을 살려내는 프레임 워크

## 좋은 객체지향 프로그래밍이란?

### 객체 지향 특징

- 추상화

추상화는 실제 세상을 객체화하는게 아니라 필요한 정보만을 중심으로 간소화 하는 것을 의미 
즉 객체들의 공통적인 속성과 기능을 중심으로 클래스를 만드는 것이 추상화의 예

- 캡슐화

추상화를 통해 객체를 정의 했다면, 객체에 필요한 데이터나 기능을 책임이 있는 객체에 그룹화 시켜주는 것을
캡슐화라고 한다. 응집성과 관련 

- 상속 

상위 클래스의 기능을 하위 클래스가 사용할 수 있는 개념. 중복되는 코드의 재사용성을 위한 개념

- 다형성

객체지향은 객체간 관계를 디자인하는 프로그래밍인데 다형성은 객체간 관계를 유연하게 해주는 특징을 말함
역할과 구현의 분리로 클라이언트는 구현 대상의 내부 구조를 몰라도 되며 내부 구조가 변경되어도 영향을 받지 않으며
대상의 역할(인터페이스)만 알면 된다는 점이 중요하다.

다형성의 본질은 인터페이스를 구현한 객체 인스턴스를 실행 시점에서 유연하게 변경할 수 있다는 점
'클라이언트를 변경하지 않고,' 서버의 구현 기능을 유연하게 변경할 수 있다.

### 스프링과 객체 지향

- 다형성이 가장 중요하다!

- 스프링은 다형성을 극대화해서 이용할 수 있게 도와준다.

- 스프링에서 이야기하는 제어의 역전(IOC), 의존관계 주입(DI)은 다형성을 활용해서 역할과 구현을 편리하게 다룰 수 있도록 지원한다.

- 스프링을 사용하면 마치 레고 블럭 조립하듯이 구현을 편리하게 변경할 수 있다.


## 좋은 객체지향 설계의 5가지 원칙(SOLID)

### SRP : 단일 책임 원칙 (single responsibility principle)
한 클래스는 하나의 책임만 가져야 한다. 하나의 책임이라는 것은 모호하지만
중요한 기준은 변경이다. 변경이 있을 때 파급 효과가 적으면 단일 책임 원칙을 잘 따른 것 

### OCP : 개방 폐쇄 원칙 (Open-Closed principle)
소프트웨어 요소는 확장에는 열려 있으나 변경에는 닫혀 있어야 한다.
다형성으로 구현체를 새로운 것으로 갈아끼는 것이 그 예. but 클라이언트 코드에서 구현 객체를 변경해야 한다면 이는 OCP 원칙을
잘 지키지 못한 예

```java
MemberRepository m = new MemoryMemberRepository(); //기존코드
MemberRepository m = new JdbcMemberReopsitory(); //변경 코드

```
이러한 문제는 어떻게 해결? -> 객체를 생성하고 연관관계를 맺어주는 별도의 조립, 설정자 필요. 스프링은 이러한 객체지향 특징을 지켜주기위해 여러가지 기능 제공

### LSP : 리스코프 치환 원칙 (Liskov substitution principle)

프로그램의 객체는 프로그램의 정확성을 깨뜨리지 않으면서 하위 타입의 인스턴스로 바꿀 수 있어야 한다.
즉 다형성에서 하위 클래스는 인터페이스 규약을 다 지켜야 한다는 것
인터페이스가 구현된 구현체는 규약내에서 신뢰성있는 수행을 해야 한다.

### ISP : 인터페이스 분리 원칙 (Interface segregation principle)

특정 클라이언트를 위한 인터페이스 여러개가 범용 인터페이스 하나보다 낫다.

자동차 인터페이스를 -> 운전 인터페이스, 정비 인터페이스로 분리하면 인터페이스가 명확해지고 대체 가능성이 높아진다.

### DIP : 의존관계 역전 원칙 (Dependency inversion principle)

프로그래머는 추상화에 의존해야지 구체화에 의존하면 안된다. 의존성 주입은 이 원칙을 따르는 방법 중 하나이다

쉽게 이야기해서 구현 클래스에 의존하지 말고 인터페이스에 의존하라는 뜻 구현체에 의존하게 되면 변경이 아주 까다로워 짐 

## 객체 지향 설계와 스프링

스프링은 다음 기술로 다형성 + OCP,DIP를 가능하게 지원한다

- DI
- DI 컨테이너 제공

클라이언트 코드의 변경 없이 기능 확장 가능하게 함 즉 쉽게 부품을 교체하듯이 개발 가능하게 함 



</div>
</details>


<details>
<summary>02 예제 스프링 없이</summary>
<div markdown="1">

## 비즈니스 요구사항
- 회원 가입, 조회
- 회원의 등급은 일반, VIP 두가지
- 자체 DB but 바꿀수도 있음
- 상품 주문할 수 있고 VIP에게는 할인 정책 적용
- 어떤 할인정책을 사용할지 미지수 

## 순수 자바코드의 개발 
MemberService, MemberRepository, OrderService를 인터페이스로 
만들어 다형성을 이용해 변경이 용이하도록 설정함.

다만 DIP와 OCP를 위배하는 부분이 있음 어디에?
```java
 private final MemberRepository memberRepository = new MemoryMemberRepository();
    //private final DiscountPolicy discountPolicy = new FixDiscountPolicy();
    //private final DiscountPolicy discountPolicy = new RateDiscountPolicy();
    //수정하는 과정에서 DIP와 OCP 위반 이거를 어떻게 해결할 수 있을까?

    //인터페이스만 의존하도록 설정했다. but 당연히 구현체가 없으니 널포인트익셉션 발생
    private DiscountPolicy discountPolicy;
    //해결하기 위해 누군가 구현 객체를 꽂아주어야 한다.
```
추상화와 구현체 모두에게 의존한다는 점에서 DIP 위반.

앱의 확장을 위해서 클라이언트 코드를 변경해야 한다는 점에서 OCP위반.


그렇다고 인터페이스에만 의존하도록 설정하면 당연하게도 구현체가 없으니 예외 발생.


해결하기 위해서는 누군가 구현 객체를 설정해주어야 한다. 

## 관심사의 분리

구현체가 다른 인터페이스의 구현체 까지 신경쓴다?

이것은 마치 배우가 직접 다른 배우를 캐스팅하는 셈 다양한 책임을 가지게 된다.

- 관심사를 분리하자
디카프리오는 어떤 여자 주인공이 선택되더라도 똑같이 공연할 수 있어야 한다.
- 공연 기획자가 필요하다
AppConfig 등장 : 구현 객체를 생성하고 연결하는 책임을 가지는 별도의 설정 클래스. 얘가 객체를 생성하고 주입해야 의미가 있는 것. 생성자를 통해 주입한다. 
- MemberServiceImpl은 이제부터 의존관계에 대한 고민은 외부에 맡기고 실행에만 집중하면 된다! -> 관심사의 분리 DIP 성공적 추상에만 의존하도록 했다.

## AppConfig는 구성영역, OrderService등의 클래스는 사용영역

- 관심사의 분리를 통한 의존성 주입의 핵심은 사용영역의 변화가 전혀 일어나지 않는다는 것 
- 구성영역은 당연하게도 변경이 일어남 공연 기획자는 공연에 대한 모든 정보를 알고 있음 

## 좋은 객체 지향 설계의 5가지 원칙의 적용

이 중 세가지가 잘 적용 되었는지 확인해보자

### SRP 단일 책임 원칙
- 한 클래스는 하나의 책임만 가져야 한다.
- 클라이언트 객체가 직접 구현 객체를 생성하고 연결하고 실행하는 다양한 책임을 가지고 있었음 
- 관심사의 분리를 통해서 SRP를 지켜냄 
### DIP 의존관계 역전 원칙 
- 프로그래머는 추상화에 의존해야지 구체화에 의존하면 안된다.
- 의존성 주입은 이 원칙을 따르는 방법 중 하나이다. 
- 새로운 할인 정책을 개발하고 적용하려고 하니 클라이언트 코드도 함께 변경해야 했다. 구현 클래스와 추상 클래스 모두에게 의존했었기 때문
- 그래서 추상화에만 의존하도록 설정했지만 인터페이스만으로는 할 수 있는게 없음 객체를 주입하고 구현체를 정해주는 AppConfig가 필요 의존관계를 주입 하도록 해서 DIP원칙도 깨지지 않도록 함 
### OCP 
- 소프트웨어 요소는 확장에는 열려 있으나 변경에는 닫혀 있어야 한다.
- 소프트 웨어 요소를 새롭게 확장하더라도 사용 영역의 변경은 닫혀있다.
- 다형성과 AppConfig를 통한 관심사의 분리로 가능한 것 

## 본격 스프링의 도입 

### IoC
- 기존 프로그램은 클라이언트 구현 객체가 스스로 필요한 서버 구현 객체를 생성하고 연결하고 실행했다. 즉 구현 객체가 프로그램의 제어 흐름을 스스로 조종했다. 이는 개발자 입장에서 자연스러운 흐름
- 반면에 AppConfig가 등장한 이후에 구현 객체는 자신의 로직을 실행하는 역할만 담당한다. 프로그램의 제어 흐름은 이제 AppConfig가 가져간다. 어떤 구현객체들이 인터페이스으 구현체로 사용될 지 AppConfig가 결정한다는 뜻 
- OrderServiceImpl은 구현체가 뭔지도 모른체 묵묵히 자신의 로직을 실행할 뿐 
- 이렇듯 프로그램의 제어 흐름을 직접 제어하는 것이 아니라 관리하는 것을 제어의 역전이라고 한다.

### 프레임워크 vs 라이브러리
- 프레임워크가 내가 작성한 코드를 제어하고, 대신 실행하면 그것은 프레임워크(JUnit)
- JUnit에서는 실행하기 전에는 beforeEach를 돌린다와 같은 라이프사이클이 있고 정해진 라이프사이클에 따라 나의 코드가 콜백식으로 사용된다. 
- 제어권이 프레임워크에 있음
- 반면에 내가 작성한 코드가 직접 제어의 흐름을 담당한다면 그것은 프레임워크가 아니라 라이브러리다.
### DI
- OrderServiceImpl은 DiscountPolicy 인터페이스에 의존한다. 실제 어떤 구현 객체가 사용될 지 모른다!
- 의존관계는 정적인 클래스 의존관계와, 실행 시점에 결정되는 동적인 객체 의존 관계를 분리해서 생각해야 한다.

### 정적인 클래스 의존관계 
- 클래스가 사용하는 import 코드만 보고 의존관계를 쉽게 판단할 수 있다. 정적인 의존관계는 애플리케이션을 실행하지 않아도 분석할 수 있음.
- but 이러한 클래스 의존관계만으로는 실제 어떤 객체가 OrderServiceImpl에 주입 될지 알 수 없다.

### 동적인 객체 인스턴스 의존 관계
- 애플리케이션 실행시점에 실제 생성된 객체 인스턴스의 참조가 연결된 의존 관계다
- 애플리케이션 실행 시점에 외부에서 실제 구현 객체를 생성하고 클라이언트에 전달해서 클라이언트와 서버의 실제 의존관계가 연결 되는 것을 의존관계 주입이라고 함
- 의존관계 주입을 사용하면 클라이언트 코드를 변경하지 않고, 클라이언트가 호출하는 대상의 타입 인스턴스 변경가능
- 의존관계 주입을 사용하면 정적인 클래스 의존관계를 변경하지 않고 동적인 객체 인스턴스 의존관계를 쉽게 변경가능

### IoC 컨테이너, DI Container
- AppConfig 처럼 객체를 생성하고 관리하면서 의존관계를 연결해 주는 것을 IoC컨테이너 또는 DI컨테이너라고 한다.
- 또는 어셈블러(조립자), 오브젝트 팩토리 등으로 불리기도 함

</div>
</details>

<details>
<summary>03 예제 스프링으로 refactoring</summary>
<div markdown="1">

## 스프링으로 전환하기

### AppConfig 스프링으로 변경

- @Configuration 과 @Bean을 통해서
```java
@Configuration
public class AppConfig {

    @Bean
    private MemberRepository memberRepository() {
        return new MemoryMemberRepository();
    }

    @Bean
    public MemberService memberService() {
        return new MemberServiceImpl(new MemoryMemberRepository());
    }

    @Bean
    public OrderService orderService() {
        return new OrderServiceImpl(memberRepository(), discountPolicy());
    }

    @Bean
    public DiscountPolicy discountPolicy() {
        return new RateDiscountPolicy(); //여기만 갈아끼면 정률 할인정책으로!
    }
}

```

### ApplicationContext
- 스프링을 모든 게 ApplicationContext로 부터 시작한다. 얘가 Bean객체를 관리함  
```java
ApplicationContext applicationContext = new AnnotationConfigApplicationContext(AppConfig.class); //어노테이션 기반 config
```
- 이 코드는 AppConfig에 있는 정보를 바탕으로 Bean 등록하고 객체를 관리하도록 하는 코드 

### 스프링 컨테이너

- ApplicationContext를 스프링 컨테이너라 한다.
- 기존에는 개발자가 AppConfig를 사용해서 직접 객체를 생성하고 DI를 했지만 이제부터는 스프링 컨테이너를 통해서 사용한다.
- 스프링 컨테이너는 @Configuration이 붙은 AppConfig를 설정 정보로 사용한다. 여기서 @Bean이라 적힌 메서드를 모두 호출해서 반환된 객체를 스프링 컨테이너에 등록한다.
- 이렇게 스프링 컨테이너에 등록된 객체를 스프링 빈이라 한다.



- 스프링 빈은 @Bean이 붙은 메서드의 명을 스프링 빈의 이름으로 사용한다 
- 이전에는 개발자가 필요한 객체를 AppConfig를 사용해서 직접 조회했지만 이제부터는 스프링 컨테이너를 통해서 필요한 스프링 빈을 찾아야 한다. 
- ac.getBean()메소드로 가능 
- 스프링 컨테이너를 사용하면 어떤 장점이 있을까?
- 지금까지는 아 다형성만으로 안되는 구나 SRP OCP DIP를 지키기 위해 AppConfig가 필요하구나 근데 이걸 Spring Bean으로 할 수 있네 요정도를 배웠고 이후에는 이걸 사용함으로써 얻을 수 있는 장점을 공부하게 될 것  

### 스프링 컨테이너 생성
- ApplicationContext를 스프링 컨테이너라 한다. 
- ApplicationContext는 인터페이스이다. 구현체는 애노테이션 방식, XML방식 등등..
- 스프링 컨테이너는 XML을 기반으로 만들 수 있고 애노테이션 기반의 자바 설정 클래스로 만들 수 있다. XML은 잘 쓰이지 않는 기술
- 우리가 했던 방식이 애노테이션 기반의 자바 설정 클래스로 스프링 컨테이너를 만든 것이다.
- 스프링 컨테이너를 생성하면 스프링 컨테이너 안의 스프링 빈 저장소에는 빈 이름을 키로 빈 객체를 밸류로 담고 있는 테이블이 존재.
- 스프링 컨테이너는 AppConfig.class를 보고 객체를 빈으로 할당 
- 요약 : 스프링 컨테이너를 생성하고 설정 정보를 참고해서 스프링 빈 등록 의존관계도 설정한다
- 참고 : 스프링은 빈을 생성하고 의존관계를 주입하는 단계가 나누어져 있다. 그런데 이렇게 자바 코드로 스프링 빈을 등록하면 생성자를 호출하면서 의존관계 주입도 한번에 처리된다. 자세한 내용은 의존관계 자동 주입에서..

### 컨테이너에 등록된 모든 빈 조회
- 모든 빈 출력하기 
- ac.getBeanDefinitionNames(); 스프링에 등록된 모든 빈 이름을 조회한다. 배열로 반환
- ac.getBean(); 빈 이름으로 빈 객체(인스턴스)를 조회한다.
- 애플리케이션 빈 출력하기
- 스프링이 내부에서 사용하는 빈은 제외하고 내가 등록한 빈만 출력할 수 있게 하자
- 스프링이 내부에서 사용하는 빈은 getRole()로 구분할 수 있다. 
- ROLE_APPLICATION : 일반적으로 사용자가 정의한 빈
- ROLE_INFRASTRUCTURE : 스프링이 내부에서 사용하는 빈 

### 스프링 빈 조회 - 상속관계
- 부모타입으로 조회하면 자식 타입도 함께 조회한다.
- 그래서 모든 자바 객체의 최고 부모인 Object타입으로 조회하면 모든 스프링 빈을 조회한다. 


### BeanFactory와 ApplicationContext

![img.png](img.png)

- BeanFactory
  - 스프링 컨테이너의 최상위 인터페이스
  - 스프링 빈을 관리하고 조회하는 역할 담당
  - 지금까지 우리가 사용했던 대부분의 기능은 (getBean과 같은..) BeanFactory가 제공하는 기능

- ApplicationContext
    - BeanFactory의 기능을 모두 상속 받아서 제공한다.
    - 빈을 관리하고 검색하는 기능을 빈팩토리가 제공해주는데 두르이 차이는 부가기능의 차이이다.
    - 애플리케이션 콘텍스트에 더 많은 부가기능이 있다는 뜻 

- ApplicationContext가 제공하는 여러 부가기능
    - 메세지 소스를 활용한 국제화 기능
      - 한국에서 들어오면 한국어, 영어권에서 들어오면 영어
    - 환경변수
      - 로컬, 개발, 운영등을 구분해서 처리
    - 애플리케이션 이벤트
      - 이벤트를 발행하고 구독하는 모델을 편리하게 지원
    - 편리한 리소스 조회
      - 파일 클래스패스, 외부 등에서 리소스를 편리하게 조회

![img_1.png](img_1.png)

### 다양한 설정 형식 지원

- 스프링 컨테이너는 다양한 형식의 설정 정보를 받아드릴 수 있게 유연하게 설계되어 있다.
  - 자바 코드, XML, Groovy 등등.. 

![img_2.png](img_2.png)

### 스프링 빈 설정 메타 정보 - BeanDefinition

- 스프링은 어떻게 이런 다양한 설정 형식을 지원하는가? 그 중심에는 BeanDefenition이라는 추상화가 있다.
- 쉽게 이야기해서 역할과 구현을 개념적으로 나눈 것 
  - XML을 읽어서 BeanDefinition을 만든다.
  - 자바 코드를 읽어서 BeanDefinition을 만든다.
  - 스프링 컨테이너는 자바 코드인지 XML인지 몰라도 된다. 오직 BeanDefinition만 알면 된다. 
- BeanDefinition을 빈 설정 메타 정보라 한다.
- @Bean, <bean>당 각각 하나씩 메타정보가 생성된다. 
    
</div>
</details>

<details>
<summary>04 싱글톤 </summary>
<div markdown="1">

## 싱글톤의 필요성
- 우리가 만들었던 스프링 없는 순수한 DI 컨테이너인 AppConfig는 요청을 할 때 마다 객체를 새로 생성한다.
- 고객 트래픽이 초당 100이 나오면 100개 객체가 생성되고 소멸된다. -> 메모리 낭비가 심함
- 해결 방안은 해당 객체가 딱 1개만 생성되고, 공유하도록 설계하면 된다. -> <U>**싱글톤 패턴***</U>

</div>
</details>